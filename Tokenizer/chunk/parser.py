""" Should convert tokens generated by lexer into commands that the interpreter will be able to exectute. 
    Should also put variables, functions and chunks into memory so interpreter can verify that these exist when they are called / used.
""" 
from chunk.token import Token,TokenTypes
from chunk.string import isempty

def error(msg, token=None):
    line_msg = "" if token == None else ("@line : " + str(token.line_number) + ", ")
    print("[ERROR] " + line_msg + msg)

class InterpreterCommands():
    ASSIGNMENT = "normal assignment"
    ASSIGNMENT_DEFINITION = "assigned to already declared variable"
    ASSIGNMENT_OPERATION = "assignment value is operation"
    ASSIGNMENT_CALL = "assignment value is gotten by call"

class Parser():

    GLOBAL_DEFINITIONS = {}
    CURRENT_SCOPE = "GLOBAL"

    @staticmethod
    def parse_line(tokens):
        
        commands = []

        # check for assignments
        assignment_token = Parser.includes(tokens, TokenTypes.ASSIGNMENT)
        if assignment_token:
            commands.extend(Parser.handle_assignment(tokens, assignment_token))

            

        return commands

    # ------------------------------------------------------------------------
    # handle methods
    # ------------------------------------------------------------------------
    @staticmethod
    def handle_assignment(tokens, assignment_token):
        assignment_token_index = Parser.get_index(tokens, TokenTypes.ASSIGNMENT)
        commands = []
        # finding the keys and separting the value
        identifier_tokens = tokens[0:assignment_token_index]
        identifier_string = Token.smash(identifier_tokens)

        # error checking
        if isempty(identifier_string):
            error("The assigned value does not have a identifier.", assignment_token)
            return []

        # finding value of assignment tokens
        value_tokens = tokens[assignment_token_index+1:]
        value_, type = Parser.get_value(value_tokens)

        # error checking
        if value_ == None or type == None:
            error("The given value for the key '" + identifier_string + "' is undefined.", assignment_token)
            return []

        # no errors have happened
        # adding the identifier to global definitions
        Parser.GLOBAL_DEFINITIONS[identifier_string] = Parser.CURRENT_SCOPE
        commands.append(Parser.create_assignment_command(identifier_string, value_, type))

        return commands


    @staticmethod
    def includes(tokens, token_type):
        for t in tokens:
            if t.type == token_type:
                return t
        return None
    
    @staticmethod
    def get_all_tokens(tokens, token_type):
        ts = []
        for t in tokens:
            if t.type == token_type:
                ts.append(t)
        return ts

    @staticmethod
    def get_index(tokens, token_type):
        for x in range(len(tokens)):
            if tokens[x].type == token_type:
                return x
        return -1

    @staticmethod
    def get_value(tokens):
        """Gets the value of an expression, used in assignments,  """
        # for t in tokens:print(str(t))

        # could be NUM, STRING or bool value
        if len(tokens) == 1:
            token = tokens[0]
            if token.type in (TokenTypes.NUM, TokenTypes.STRING, TokenTypes.BOOL):
                if token.type == TokenTypes.BOOL:
                    return True if token.value =="true" else False, InterpreterCommands.ASSIGNMENT
                return token.value, InterpreterCommands.ASSIGNMENT
        
        # check if remainder is a definition
        possible_id = Token.smash(tokens)
        if possible_id in Parser.GLOBAL_DEFINITIONS.keys():
            print("found reference to defnini")
            return possible_id, InterpreterCommands.ASSIGNMENT_DEFINITION

        # check for a function call of chunkfunctioncall

        return None, None
    
    @staticmethod
    def create_assignment_command(key, value, type=InterpreterCommands.ASSIGNMENT):
        return {
            "command_type" : type,
            "key" : key,
            "value" : value
        }
     